# 如果a+b+c=1000,且a^2+b^2=c^2(a,b,c为自然数),如果求出a、b、c可能的组合；
import time

# a
# b
# c
# c = 1000 -a -b

start_time = time.time()

# for a in range(0, 1001):
#     for b in range(0, 1001):
#         for c in range(0, 1001):
#             if a+b+c == 1000 and a**2 + b**2 == c**2:
#                 print("a:%s,b:%s,c:%s" % (a,b,c))

# T = 1000 * 1000 * 1000 * 2
# T = 2000 * 2000 * 2000 * 2
# T = N * N * N *2
# T(n) = n^3 * 2
# T(n) = n^3 * 10  # 不必太关心每轮基本操作的数量；

# T(n) = n^3   # 跟上面的在同一个数量级上的，而且走势也是一致的；

# “大O记法”：对于单调的整数函数f，如果存在一个整数函数g和实常数c>0，使得对于充分大的n总有f(n)<=c*g(n)，
# 就说函数g是f的一个渐近函数（忽略常数），记为f(n)=O(g(n))。
# 也就是说，在趋向无穷的极限意义下，函数f的增长速度受到函数g的约束，亦即函数f与函数g的特征相似。
#
# 时间复杂度：假设存在函数g，使得算法A处理规模为n的问题示例所用时间为T(n)=O(g(n))，
# 则称O(g(n))为算法A的渐近时间复杂度，简称时间复杂度，记为T(n)


for a in range(0, 1001):
    for b in range(0, 1001):
       c = 1000 - a - b
       if a**2 + b**2 == c**2:
           print("a:%s,b:%s,c:%s" % (a,b,c))
# T(n) = n*n * (1+max(1,0))
# T(n) = n^2 * 2
# T(n) = n^2
# T(n) = O(n^2)

    # 每台机器执行的总时间不同；
    # 但是执行基本运算数量大体相同；
end_time = time.time()
print("times:%d" % (end_time-start_time))
print("finished")

# 算法效率衡量：
"""
    实现算法程序的执行时间可以反应出算法的效率，即算法的优劣。
    单纯依靠运行的时间来比较算法的优劣并不一定是客观准确的！
"""

# 最坏时间复杂度：
"""
分析算法时，存在几种可能的考虑：
    算法完成工作最少需要多少基本操作，即最优时间复杂度
    算法完成工作最多需要多少基本操作，即最坏时间复杂度
    算法完成工作平均需要多少基本操作，即平均时间复杂度
    
我们主要关注算法的最坏情况，亦即最坏时间复杂度。
"""

# 时间复杂度的几条基本计算规则：
"""
    1、基本操作，即只有常数项，认为其时间复杂度为O(1)
    2、顺序结构，时间复杂度按加法进行计算
    3、循环结构，时间复杂度按乘法进行计算
    4、分支结构，时间复杂度取最大值
    5、判断一个算法的效率时，往往只需要关注操作数量的最高次项，其它次要项和常数项可以忽略
    6、在没有特殊说明时，我们所分析的算法的时间复杂度都是指最坏时间复杂度
"""
